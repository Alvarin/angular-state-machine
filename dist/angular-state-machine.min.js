/**
 * AngularJS service to implement a finite state machine.
 * @version v1.1.1 - 2015-08-11
 * @link https://github.com/tafax/angular-state-machine
 * @author Matteo Tafani Alunno <matteo.tafanialunno@gmail.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"use strict";function MachineConfiguration(a){var b={},c=[],d={};this.getStates=function(){return b},this.getMessages=function(){return c},this.getTransitions=function(){return d},this.extend=function(b){a=angular.merge(a,b)},this.configure=function(){if(!a.hasOwnProperty("init"))throw"You have to create 'init' state.";for(var e in a)if(a.hasOwnProperty(e)){var f=a[e];f.name=e;var g={};if(f.hasOwnProperty("transitions")){g=f.transitions;for(var h in g)g.hasOwnProperty(h)&&c.indexOf(h)<0&&c.push(h);delete f.transitions}d.hasOwnProperty(e)||(d[e]={}),angular.extend(d[e],g),b.hasOwnProperty(e)||(b[e]={}),angular.extend(b[e],f)}}}function StateMachine(a,b){this.initialize=function(){a.initialize(b)},this.getStates=function(){return a.getStates(b)},this.getMessages=function(){return a.getMessages(b)},this.hasMessage=function(c){return a.hasMessage(b,c)},this.isAvailable=function(c){return a.isAvailable(b,c)},this.available=function(){return a.available(b)},this.send=function(c,d){return a.send(b,c,d)}}function MachineStrategy(){}function SyncStrategy(a,b){MachineStrategy.call(this),this.currentState=null,this.$q=a,this.$injector=b}var FSM=angular.module("FSM",[]);FSM.provider("stateMachine",function(){var a;this.config=function(b){a=b},this.$get=["$q","$injector",function(b,c){return new StateMachine(new SyncStrategy(b,c),new MachineConfiguration(a))}]}),MachineStrategy.prototype.initialize=function(a){},MachineStrategy.prototype.getStates=function(a){},MachineStrategy.prototype.getMessages=function(a){},MachineStrategy.prototype.hasMessage=function(a,b){},MachineStrategy.prototype.isAvailable=function(a,b){},MachineStrategy.prototype.available=function(a){},MachineStrategy.prototype.send=function(a,b,c,d){},MachineStrategy.prototype=new MachineStrategy,SyncStrategy.prototype.initialize=function(a){a.configure();var b=a.getStates();this.currentState=b.init,this.currentState.params={}},SyncStrategy.prototype.getStates=function(a){return Object.keys(a.getStates())},SyncStrategy.prototype.getMessages=function(a){return a.getMessages()},SyncStrategy.prototype.hasMessage=function(a,b){var c=a.getMessages();return c.indexOf(b)>=0},SyncStrategy.prototype.isAvailable=function(a,b){var c=a.getTransitions(),d=c[this.currentState.name];return d.hasOwnProperty(b)},SyncStrategy.prototype.available=function(a){var b=a.getTransitions(),c=b[this.currentState.name];return Object.keys(c)},SyncStrategy.prototype.send=function(a,b,c){var d=this;if(d.hasMessage(a,b)&&d.isAvailable(a,b)){var e=a.getTransitions(),f=e[d.currentState.name][b];if(f instanceof Array){var g=[];for(var h in f){var i=f[h];d.$injector.invoke(i.predicate,this,d.currentState)&&g.push(i.to)}if(g.length>1)throw"Unable to execute transition in state '"+d.currentState.name+"'. More than one predicate is passed.";f=g[0]}var j=a.getStates(),k=j[f],l={};return l=angular.merge(l,d.currentState),delete l.action,c&&(l.params=angular.merge(l.params,c)),d.$q.when(d.$injector.invoke(k.action,d,l)).then(function(a){!a&&d.currentState.params?k.params=d.currentState.params:(k.hasOwnProperty("params")||(k.params={}),k.params=angular.merge(k.params,a)),d.currentState=k})}};